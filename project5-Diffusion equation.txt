## Written in CoCalc in Jupyter notebook ##
## CELL 1 ##

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from IPython.display import HTML
from scipy.optimize import curve_fit
"""
This cell implements a diffusion equation for abox of side length 1 formatted
as a 101x101 grid where the initial state has 10 particles at the centre of the
grid. This cell returns an visual representation of this diffusion over time in
the form of an animation.

The main body of this is the for loop which progresses the diffusion for each
time step. The loop saves an image of the diffusion for every 0.2 seconds
passed. For seperately found step values a gaussian function is fitted to the
particles in the centre row of the grid and the standard deviation is saved.
It also saves 30 summations of the particles in the grid that are evenly spaced
in the time evolution.

Finally the animation is produced and saved.
"""

# CONSTANTS =========
D = 0.001
L = 1  # side length of box
N = 101  # gridpoints in one-d
dt = 0.01  # time step
dd = L / N  # postion step

C = np.zeros((N, N))  # grid for particles
Cp = np.zeros((N, N))  # grid copy

# Set particles at the center:
C[N // 2, N // 2] = 10
k = dt / dd / dd * D

# times for standard deviation plotting
times = (((np.arange(30) * np.sqrt(10) / 29)**2) / dt)  # provides even spacing
times = times.astype(int)

tmax = 100  # max time
steps = int(tmax / dt) + 1  # iterations

# FUNCTIONS ==============


def gauss(x, A, sd):
    """
    A guassian function to be used in curve_fit

    Inputs:
        x (float): normally distributed variable
        A (float): amplitude of the curve
        sd (float): standard deviation of the curve
    Outputs:
        The probability distribution in the form of a bell curve
    """
    return A * 1 / (sd * np.sqrt(2 * np.pi)) * np.exp(-1 / 2 *
                                                      ((x - N / 200) / sd)**2)


# METHOD ============

sds = []  # empty list for standard deviations
cnt = []  # empty list for particle count
ims = []  # empty list for images
fig = plt.figure()  # figure for images to be plotted on

for i in range(steps):
    # Updates the diffusion of the particles in the middle region of the grid
    Cp[1:-1,
       1:-1] = C[1:-1, 1:-1] + k * (C[2:, 1:-1] + C[0:-2, 1:-1] + C[1:-1, 2:] +
                                    C[1:-1, 0:-2] - 4 * C[1:-1, 1:-1])
    # Updates the boundaries
    Cp[0, 1:-1] = Cp[1, 1:-1]
    Cp[-1, 1:-1] = Cp[-2, 1:-1]
    Cp[1:-1, 0] = Cp[1:-1, 1]
    Cp[1:-1, -1] = Cp[1:-1, -2]
    # Updates the corners
    Cp[0, 0] = Cp[1, 1]
    Cp[0, -1] = Cp[1, -2]
    Cp[-1, 0] = Cp[-2, 1]
    Cp[-1, -1] = Cp[-2, -2]

    # swap C and Cp so that they don't end up as the same array:
    C, Cp = Cp, C

    if i % 20 == 0:  # saves image every 0.2 seconds
        ims.append((plt.pcolormesh(C.copy(), vmin = 0), ))

    if i in times:  # fits the center row particle values to a bell curve
        y = C[:, N // 2]
        x = np.arange(len(y)) / 101
        param, cov = curve_fit(gauss, x, y, (10, 0.01))
        sds.append(param[1])  # saves the standard deviation

    if i % (steps // 30) == 0:  # sums particles in grid
        # (steps // 30) results in 30 sums in the final list
        # remove edges to avoid particle count issue at boundaries
        cnt.append(np.sum(C[1:-1, 1:-1]))

# ANIMATION ==========

imani = animation.ArtistAnimation(fig, ims, interval=20, repeat=False)

# repeat is ignored with the file output we produce here, but can be
# useful for other output forms.
# Save to a file: (which can be viewed from outside of the notebook
# or from within the notebook...

imani.save('diffusion.webm', extra_args=['-vcodec', 'libvpx'])

plt.close()  # this prevents a stray plot from appearing.

del ims  # these two lines allow the memory held by the images
del imani  # to be released. This will be important on cocalc.
# Insert the file into the notebook:
# this links the video into the notebook page:
HTML('''<video controls autoplay> <source src="diffusion.webm"
        type="video/webm"></video>''')

## CELL 2 ##


# plot of Gaussian width vs sqrt(t)
"""
This cell plots the standard deviations at different times as found in the
first cell. These values are plotted against evenly spaced square root values
of time.
The plotted values are then compared to a analytical line in the plot given by
y = sqrt(2*D*t)
"""

# time points to match indexed standard deviations
x = np.arange(30) * np.sqrt(10) / 29
y = np.array(sds)  # standard deviations
y_analytic = np.sqrt(2 * D) * x  # analytic standard deviation line

# PLOTTING ============

plt.plot(x, y_analytic, 'r-', label="Analytic line")
plt.plot(x, y, "o", label="Plotted points")
plt.title("Standard deviation evolution")
plt.xlabel("Square root of time ($s^{1/2}$)")
plt.ylabel("Standard deviation")
plt.legend()
plt.show


## CELL 3 ##


# This cell plots the particle count as found in the first cell versus time

t = np.arange(steps)[::333] / 100  # time steps to match indexed points

# PLOTTING ==========

plt.plot(t, cnt)
plt.title("Particle count")
plt.xlabel("Time [s]")
plt.ylabel("Particle count")
plt.show()
